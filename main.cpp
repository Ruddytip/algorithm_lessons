#include <iostream>
#include "geek.hpp"
#include <ctime> // Для srand()

// Task 1
// Написать функцию проверяющую является ли бинарное дерево сбалансированным и написать программу, которая:
// создаст [50] деревьев по [10000] узлов и заполнит узлы случайными целочисленными значениями;
// рассчитает, какой процент из созданных деревьев является сбалансированными.

// Реализовано в файле geek.hpp в классе Tree

// ================================================================================================

// Task 2
// Написать рекурсивную функцию бинарного поиска в дереве хранящемся в узлах, а не в массиве.

// Реализовано в файле geek.hpp в классе Tree

// ================================================================================================

int main(){
    // Проверка первого задания
    std::cout << "Task1:\n";
    const int TREES = 10000; // Кол-ва деревьев
    const int SIZE = 50; // Кол-во элементов
    // Максимальное кол-во элементов в дереве 13, для того, чтобы оно случайно получилось сбалансированным
    int summCountBalance = 0;
    Tree t1;
    srand(time(0));
    for(int i = 0; i < TREES; ++i){
        t1.clear();
        for(int j = 0; j < SIZE; ++j){
            t1.push(rand()%10);
        }
        if(t1.isBalanced()) summCountBalance++;
    }
    double result = double(summCountBalance) / double(TREES) * 100.;
    std::cout << result << std::endl;
    // ==========================================

    // Проверка второго задания
    std::cout << "Task2:\n";
    Tree t2("2(1(2,2(3(5),3)),4(,5(0,0(9,8(2,7)))))");
    t2.printDiagram();
    // ==========================================
    return 0;
}